<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Hand Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; color: white; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #input-video { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; z-index: 0; }
        
        /* UI Panel */
        #ui-panel {
            position: absolute; top: 20px; right: 20px; width: 280px;
            background: rgba(20, 20, 25, 0.75);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 16px; padding: 20px; z-index: 10;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        h1 { font-size: 1.1rem; margin: 0 0 15px 0; font-weight: 600; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 8px; font-size: 0.85rem; color: #aaa; }
        
        /* Buttons */
        .shape-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        button {
            background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1);
            color: #ddd; padding: 8px; border-radius: 6px; cursor: pointer; transition: all 0.2s; font-size: 0.8rem;
        }
        button:hover { background: rgba(255, 255, 255, 0.2); }
        button.active { background: #00d2ff; color: #000; font-weight: 700; border-color: #00d2ff; }
        
        /* Color Picker */
        input[type="color"] { -webkit-appearance: none; border: none; width: 100%; height: 35px; border-radius: 6px; background: none; cursor: pointer; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; }

        /* Status */
        #status { margin-top: 15px; font-size: 0.75rem; color: #888; display: flex; align-items: center; gap: 8px; }
        .indicator { width: 8px; height: 8px; border-radius: 50%; background-color: #f03e3e; transition: background 0.3s; }
        .indicator.active { background-color: #51cf66; box-shadow: 0 0 6px #51cf66; }
        
        /* Loader */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 20; display: flex; flex-direction: column;
            justify-content: center; align-items: center; transition: opacity 0.5s;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid #00d2ff;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>

    <!-- 1. Load MediaPipe Globally (Fixes Module Loading Issues) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div id="loader-text">Loading AI Models...</div>
    </div>

    <video id="input-video" playsinline></video>
    <div id="canvas-container"></div>

    <div id="ui-panel">
        <h1>Particle Control</h1>
        <div class="control-group">
            <label>Shape</label>
            <div class="shape-grid">
                <button class="shape-btn active" data-shape="heart">Heart</button>
                <button class="shape-btn" data-shape="flower">Flower</button>
                <button class="shape-btn" data-shape="saturn">Saturn</button>
                <button class="shape-btn" data-shape="buddha">Buddha</button>
                <button class="shape-btn" data-shape="fireworks">Fireworks</button>
            </div>
        </div>
        <div class="control-group">
            <label>Color</label>
            <input type="color" id="color-picker" value="#00d2ff">
        </div>
        <div id="status">
            <div class="indicator" id="cam-indicator"></div>
            <span id="status-text">Allow camera to begin...</span>
        </div>
    </div>

    <!-- 2. Main Application Logic -->
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';

        // State
        const CONFIG = { count: 18000, size: 0.12 };
        let currentShape = 'heart';
        let handDistance = 0; 
        let handTension = 0;
        let isHandDetected = false;

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.0;

        // --- Particles ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.count * 3);
        const targetPositions = new Float32Array(CONFIG.count * 3);
        
        // Init positions
        for(let i=0; i<CONFIG.count * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 15;
            targetPositions[i] = positions[i];
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Texture
        const getTexture = () => {
            const cvs = document.createElement('canvas'); cvs.width = 32; cvs.height = 32;
            const ctx = cvs.getContext('2d');
            const grd = ctx.createRadialGradient(16,16,0,16,16,16);
            grd.addColorStop(0,'rgba(255,255,255,1)'); grd.addColorStop(0.4,'rgba(255,255,255,0.5)'); grd.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle = grd; ctx.fillRect(0,0,32,32);
            return new THREE.Texture(cvs);
        }
        const tex = getTexture(); tex.needsUpdate = true;

        const material = new THREE.PointsMaterial({
            size: CONFIG.size, color: 0x00d2ff, map: tex,
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- Shape Logic ---
        function generateShape(type) {
            const targets = new Float32Array(CONFIG.count * 3);
            for (let i = 0; i < CONFIG.count; i++) {
                let x=0, y=0, z=0;
                
                if (type === 'heart') {
                    const t = Math.random() * Math.PI * 2;
                    const hx = 16 * Math.pow(Math.sin(t), 3);
                    const hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    const thick = (Math.random()-0.5) * 2 * (1 - Math.abs(t-Math.PI)/Math.PI*0.5);
                    x = hx*0.2; y = hy*0.2; z = thick;
                } 
                else if (type === 'flower') {
                    const u = Math.random()*Math.PI*2, v = Math.random()*Math.PI;
                    const r = 1 + Math.sin(6*u) * 0.5; // 6 petals
                    x = r * Math.sin(v)*Math.cos(u)*2.5; y = r*Math.sin(v)*Math.sin(u)*2.5; z = r*Math.cos(v)*0.8;
                }
                else if (type === 'saturn') {
                    if (Math.random()>0.35) { // Planet
                        const u=Math.random()*Math.PI*2, v=Math.random()*Math.PI;
                        const r=2.5; x=r*Math.sin(v)*Math.cos(u); y=r*Math.sin(v)*Math.sin(u); z=r*Math.cos(v);
                    } else { // Ring
                        const a = Math.random()*Math.PI*2; const d = 3.5 + Math.random()*2;
                        x = Math.cos(a)*d; z = Math.sin(a)*d; y = (Math.random()-0.5)*0.2;
                    }
                }
                else if (type === 'buddha') { // Abstract Statue (Torus Knot)
                    const u = Math.random()*Math.PI*2 * 3, v = Math.random()*Math.PI*2;
                    const R = 2 + Math.cos(2*u); // Knot shape
                    x = (R * Math.cos(u) + Math.cos(3*u))*1.2;
                    y = (R * Math.sin(u) + Math.sin(3*u))*1.2;
                    z = Math.sin(v) * 1.5;
                }
                else if (type === 'fireworks') {
                    const u=Math.random()*Math.PI*2, v=Math.random()*Math.PI, r=Math.random()*6;
                    x=r*Math.sin(v)*Math.cos(u); y=r*Math.sin(v)*Math.sin(u); z=r*Math.cos(v);
                }

                targets[i*3] = x; targets[i*3+1] = y; targets[i*3+2] = z;
            }
            // Update targets
            for(let i=0; i<targetPositions.length; i++) targetPositions[i] = targets[i];
        }
        generateShape('heart');

        // --- MediaPipe Logic (Global Scope) ---
        const videoElement = document.getElementById('input-video');
        
        // Wait for window.Hands to load
        function initVision() {
            if (!window.Hands) {
                setTimeout(initVision, 100);
                return;
            }

            const hands = new window.Hands({locateFile: (file) => {
                // IMPORTANT: Point to the correct CDN for assets
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults((results) => {
                // Hide loader once we get first result
                document.getElementById('loader').style.opacity = '0';
                setTimeout(() => document.getElementById('loader').style.display = 'none', 500);

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    isHandDetected = true;
                    document.getElementById('cam-indicator').classList.add('active');

                    // 1. Two Hands Scale
                    if (results.multiHandLandmarks.length === 2) {
                        const h1 = results.multiHandLandmarks[0][0]; // Wrist
                        const h2 = results.multiHandLandmarks[1][0]; // Wrist
                        const dist = Math.sqrt(Math.pow(h1.x - h2.x, 2) + Math.pow(h1.y - h2.y, 2));
                        
                        // Smooth mapping
                        let targetD = (dist - 0.2) * 4; 
                        handDistance += (targetD - handDistance) * 0.1; // Smooth lerp
                        document.getElementById('status-text').innerText = "Hands Detected: Scaling";
                    } else {
                        // Single hand detected
                        document.getElementById('status-text').innerText = "Show two hands to scale";
                    }

                    // 2. Fist Tension (Check all hands)
                    let maxTension = 0;
                    results.multiHandLandmarks.forEach(lm => {
                        const wrist = lm[0];
                        const middleTip = lm[12];
                        const d = Math.sqrt(Math.pow(wrist.x - middleTip.x, 2) + Math.pow(wrist.y - middleTip.y, 2));
                        // d < 0.2 is usually a fist
                        let t = d < 0.25 ? (1 - d/0.25) : 0;
                        if(t > maxTension) maxTension = t;
                    });
                    
                    handTension += (maxTension - handTension) * 0.1;

                } else {
                    isHandDetected = false;
                    document.getElementById('cam-indicator').classList.remove('active');
                    document.getElementById('status-text').innerText = "Waiting for hands...";
                    handDistance *= 0.95;
                    handTension *= 0.9;
                }
            });

            // Start Camera
            const cameraUtils = new window.Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            cameraUtils.start();
        }

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            const arr = geometry.attributes.position.array;
            
            // Calculate global scale
            let s = isHandDetected ? (0.8 + handDistance) : (1 + Math.sin(time)*0.1);
            particles.scale.lerp(new THREE.Vector3(s,s,s), 0.1);

            // Particle Movement
            for(let i=0; i<CONFIG.count; i++) {
                const idx = i*3;
                const tx=targetPositions[idx], ty=targetPositions[idx+1], tz=targetPositions[idx+2];

                // Morphing speed
                arr[idx] += (tx - arr[idx]) * 4 * delta;
                arr[idx+1] += (ty - arr[idx+1]) * 4 * delta;
                arr[idx+2] += (tz - arr[idx+2]) * 4 * delta;

                // Tension Jitter (Fist)
                if(handTension > 0.05) {
                    const j = handTension * 0.2;
                    arr[idx] += (Math.random()-0.5)*j;
                    arr[idx+1] += (Math.random()-0.5)*j;
                    arr[idx+2] += (Math.random()-0.5)*j;
                }

                // Fireworks Drift
                if(currentShape === 'fireworks') {
                    arr[idx] *= 1.01; arr[idx+1] *= 1.01; arr[idx+2] *= 1.01;
                    if(Math.abs(arr[idx]) > 10) { 
                        arr[idx]=tx; arr[idx+1]=ty; arr[idx+2]=tz; // Reset
                    }
                }
            }
            geometry.attributes.position.needsUpdate = true;
            
            // Rotation
            if(isHandDetected) particles.rotation.y += 0.002;
            else controls.update();

            renderer.render(scene, camera);
        }

        // --- UI Events ---
        document.querySelectorAll('.shape-btn').forEach(b => {
            b.addEventListener('click', (e) => {
                document.querySelectorAll('.shape-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                currentShape = e.target.dataset.shape;
                generateShape(currentShape);
            });
        });
        document.getElementById('color-picker').addEventListener('input', (e) => {
            material.color.set(e.target.value);
        });
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        initVision();
        animate();
    </script>
</body>
</html>